{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"BERTopic \u00b6 BERTopic is a topic modeling technique that leverages BERT embeddings and c-TF-IDF to create dense clusters allowing for easily interpretable topics whilst keeping important words in the topic descriptions. Corresponding medium post can be found here . About the Project \u00b6 The initial purpose of this project was to generalize Top2Vec such that it could be used with state-of-art pre-trained transformer models. However, this proved difficult due to the different natures of Doc2Vec and transformer models. Instead, I decided to come up with a different algorithm that could use BERT and \ud83e\udd17 transformers embeddings. The results is BERTopic , an algorithm for generating topics using state-of-the-art embeddings. Installation \u00b6 PyTorch 1.2.0 or higher is recommended. If the install below gives an error, please install pytorch first here . Installation can be done using pypi : pip install bertopic Usage \u00b6 Below is an example of how to use the model. The example uses the 20 newsgroups dataset. from bertopic import BERTopic from sklearn.datasets import fetch_20newsgroups docs = fetch_20newsgroups ( subset = 'all' )[ 'data' ] model = BERTopic ( \"distilbert-base-nli-mean-tokens\" , verbose = True ) topics = model . fit_transform ( docs ) The resulting topics can be accessed through model.get_topic(topic) : >>> model . get_topic ( 9 ) [( 'game' , 0.005251396890032802 ), ( 'team' , 0.00482651185323754 ), ( 'hockey' , 0.004335032060690186 ), ( 'players' , 0.0034782716706978963 ), ( 'games' , 0.0032873248432630227 ), ( 'season' , 0.003218987432255393 ), ( 'play' , 0.0031855141725669637 ), ( 'year' , 0.002962343114817677 ), ( 'nhl' , 0.0029577648449943144 ), ( 'baseball' , 0.0029245163154193524 )] You can find an overview of all models currently in BERTopic here and here . Overview \u00b6 Methods Code Returns Access single topic model.get_topic(12) Tuple[Word, Score] Access all topics model.get_topic() List[Tuple[Word, Score]] Get single topic freq model.get_topic_freq(12) int Get all topic freq model.get_topics_freq() DataFrame Fit the model model.fit(docs]) - Predict new documents model.transform([new_doc]) List[int] Save model model.save(\"my_model\") - Load model BERTopic.load(\"my_model\") - NOTE : The embeddings itself are not preserved in the model as they are only vital for creating the clusters. Therefore, it is advised to only use fit and then transform if you are looking to generalize the model to new documents. For existing documents, it is best to use fit_transform directly as it only needs to generate the document embeddings once. Google Colaboratory \u00b6 Since we are using transformer-based embeddings you might want to leverage gpu-acceleration to speed up the model. For that, I have created a tutorial Google Colab Notebook that you can use to run the model as shown above. If you want to tweak the inner workings or follow along with the medium post, use this notebook instead. References \u00b6 Angelov, D. (2020). Top2Vec: Distributed Representations of Topics. arXiv preprint arXiv :2008.09470.","title":"Index"},{"location":"index.html#bertopic","text":"BERTopic is a topic modeling technique that leverages BERT embeddings and c-TF-IDF to create dense clusters allowing for easily interpretable topics whilst keeping important words in the topic descriptions. Corresponding medium post can be found here .","title":"BERTopic"},{"location":"index.html#about-the-project","text":"The initial purpose of this project was to generalize Top2Vec such that it could be used with state-of-art pre-trained transformer models. However, this proved difficult due to the different natures of Doc2Vec and transformer models. Instead, I decided to come up with a different algorithm that could use BERT and \ud83e\udd17 transformers embeddings. The results is BERTopic , an algorithm for generating topics using state-of-the-art embeddings.","title":"About the Project"},{"location":"index.html#installation","text":"PyTorch 1.2.0 or higher is recommended. If the install below gives an error, please install pytorch first here . Installation can be done using pypi : pip install bertopic","title":"Installation"},{"location":"index.html#usage","text":"Below is an example of how to use the model. The example uses the 20 newsgroups dataset. from bertopic import BERTopic from sklearn.datasets import fetch_20newsgroups docs = fetch_20newsgroups ( subset = 'all' )[ 'data' ] model = BERTopic ( \"distilbert-base-nli-mean-tokens\" , verbose = True ) topics = model . fit_transform ( docs ) The resulting topics can be accessed through model.get_topic(topic) : >>> model . get_topic ( 9 ) [( 'game' , 0.005251396890032802 ), ( 'team' , 0.00482651185323754 ), ( 'hockey' , 0.004335032060690186 ), ( 'players' , 0.0034782716706978963 ), ( 'games' , 0.0032873248432630227 ), ( 'season' , 0.003218987432255393 ), ( 'play' , 0.0031855141725669637 ), ( 'year' , 0.002962343114817677 ), ( 'nhl' , 0.0029577648449943144 ), ( 'baseball' , 0.0029245163154193524 )] You can find an overview of all models currently in BERTopic here and here .","title":"Usage"},{"location":"index.html#overview","text":"Methods Code Returns Access single topic model.get_topic(12) Tuple[Word, Score] Access all topics model.get_topic() List[Tuple[Word, Score]] Get single topic freq model.get_topic_freq(12) int Get all topic freq model.get_topics_freq() DataFrame Fit the model model.fit(docs]) - Predict new documents model.transform([new_doc]) List[int] Save model model.save(\"my_model\") - Load model BERTopic.load(\"my_model\") - NOTE : The embeddings itself are not preserved in the model as they are only vital for creating the clusters. Therefore, it is advised to only use fit and then transform if you are looking to generalize the model to new documents. For existing documents, it is best to use fit_transform directly as it only needs to generate the document embeddings once.","title":"Overview"},{"location":"index.html#google-colaboratory","text":"Since we are using transformer-based embeddings you might want to leverage gpu-acceleration to speed up the model. For that, I have created a tutorial Google Colab Notebook that you can use to run the model as shown above. If you want to tweak the inner workings or follow along with the medium post, use this notebook instead.","title":"Google Colaboratory"},{"location":"index.html#references","text":"Angelov, D. (2020). Top2Vec: Distributed Representations of Topics. arXiv preprint arXiv :2008.09470.","title":"References"},{"location":"algorithm.html","text":"The Algorithm \u00b6 The algorithm contains, roughly, 3 stages: Extract document embeddings with Sentence Transformers Cluster document embeddings to create groups of similar documents with UMAP and HDBSCAN Extract and reduce topics with c-TF-IDF Sentence Transformer \u00b6 We start by creating document embeddings from a set of documents using sentence-transformer . These models are pre-trained for many language and are great for creating either document- or sentence-embeddings. If you have long documents, I would advise you to split up your documents into paragraphs or sentences as a BERT-based model in sentence-transformer typically has a token limit. UMAP + HDBSCAN \u00b6 Next, in order to cluster the documents using a clustering algorithm such as HDBSCAN we first need to reduce its dimensionality as HDBCAN is prone to the curse of dimensionality. Thus, we first lower dimensionality with UMAP as it preserves local structure well after which we can use HDBSCAN to cluster similar documents. c-TF-IDF \u00b6 What we want to know from the clusters that we generated, is what makes one cluster, based on their content, different from another? To solve this, we can modify TF-IDF such that it allows for interesting words per topic instead of per document. When you apply TF-IDF as usual on a set of documents, what you are basically doing is comparing the importance of words between documents. Now, what if, we instead treat all documents in a single category (e.g., a cluster) as a single document and then apply TF-IDF? The result would be importance scores for words within a cluster. The more important words are within a cluster, the more it is representative of that topic. In other words, if we extract the most important words per cluster, we get descriptions of topics ! Each cluster is converted to a single document instead of a set of documents. Then, the frequency of word t are extracted for each class i and divided by the total number of words w . This action can now be seen as a form of regularization of frequent words in the class. Next, the total, unjoined, number of documents m is divided by the total frequency of word t across all classes n .","title":"Algorithm"},{"location":"algorithm.html#the-algorithm","text":"The algorithm contains, roughly, 3 stages: Extract document embeddings with Sentence Transformers Cluster document embeddings to create groups of similar documents with UMAP and HDBSCAN Extract and reduce topics with c-TF-IDF","title":"The Algorithm"},{"location":"algorithm.html#sentence-transformer","text":"We start by creating document embeddings from a set of documents using sentence-transformer . These models are pre-trained for many language and are great for creating either document- or sentence-embeddings. If you have long documents, I would advise you to split up your documents into paragraphs or sentences as a BERT-based model in sentence-transformer typically has a token limit.","title":"Sentence Transformer"},{"location":"algorithm.html#umap-hdbscan","text":"Next, in order to cluster the documents using a clustering algorithm such as HDBSCAN we first need to reduce its dimensionality as HDBCAN is prone to the curse of dimensionality. Thus, we first lower dimensionality with UMAP as it preserves local structure well after which we can use HDBSCAN to cluster similar documents.","title":"UMAP + HDBSCAN"},{"location":"algorithm.html#c-tf-idf","text":"What we want to know from the clusters that we generated, is what makes one cluster, based on their content, different from another? To solve this, we can modify TF-IDF such that it allows for interesting words per topic instead of per document. When you apply TF-IDF as usual on a set of documents, what you are basically doing is comparing the importance of words between documents. Now, what if, we instead treat all documents in a single category (e.g., a cluster) as a single document and then apply TF-IDF? The result would be importance scores for words within a cluster. The more important words are within a cluster, the more it is representative of that topic. In other words, if we extract the most important words per cluster, we get descriptions of topics ! Each cluster is converted to a single document instead of a set of documents. Then, the frequency of word t are extracted for each class i and divided by the total number of words w . This action can now be seen as a form of regularization of frequent words in the class. Next, the total, unjoined, number of documents m is divided by the total frequency of word t across all classes n .","title":"c-TF-IDF"},{"location":"api/bertopic.html","text":"BERTopic \u00b6 Transformer-based model for Topic Modeling Parameters Name Type Description Default bert_model str Model to use. Overview of options can be found here https://www.sbert.net/docs/pretrained_models.html 'distilbert-base-nli-mean-tokens' top_n_words int The number of words per topic to extract 20 nr_topics int Specifying the number of topics will reduce the initial number of topics to the value specified. This reduction can take a while as each reduction in topics (-1) activates a c-TF-IDF calculation. IF this is set to None, no reduction is applied. None n_gram_range Tuple[int, int] The n-gram range for the CountVectorizer. Advised to keep high values between 1 and 3. More would likely lead to memory issues. (1, 1) min_topic_size int The minimum size of the topic. 30 n_neighbors int The size of local neighborhood (in terms of number of neighboring sample points) used for manifold approximation (UMAP). 15 n_components int The dimension of the space to embed into when reducing dimensionality with UMAP. 5 stop_words Union[str, List[str]] Stopwords that can be used as either a list of strings, or the name of the language as a string. For example: 'english' or ['the', 'and', 'I']. None verbose bool Changes the verbosity of the model, Set to True if you want to track the stages of the model. False Usage: from bertopic import BERTopic from sklearn.datasets import fetch_20newsgroups docs = fetch_20newsgroups ( subset = 'all' )[ 'data' ] model = BERTopic ( \"distilbert-base-nli-mean-tokens\" , verbose = True ) topics = model . fit_transform ( docs ) fit ( self , documents ) \u00b6 Show source code in bertopic\\model.py 90 91 92 93 94 95 96 97 98 def fit ( self , documents : List [ str ]): \"\"\" Fit the models (Bert, UMAP, and, HDBSCAN) on a collection of documents and generate topics Arguments: documents: A list of documents to fit on \"\"\" check_documents_type ( documents ) self . fit_transform ( documents ) return self Fit the models (Bert, UMAP, and, HDBSCAN) on a collection of documents and generate topics Parameters Name Type Description Default documents List[str] A list of documents to fit on required fit_transform ( self , documents ) \u00b6 Show source code in bertopic\\model.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def fit_transform ( self , documents : List [ str ]) -> Tuple [ List [ int ], np . ndarray ]: \"\"\" Fit the models on a collection of documents, generate topics, and return the docs with topics Arguments: documents: A list of documents to fit on Returns: predictions: Topic predictions for each documents probabilities: The topic probability distribution \"\"\" check_documents_type ( documents ) documents = pd . DataFrame ({ \"Document\" : documents , \"ID\" : range ( len ( documents )), \"Topic\" : None }) # Extract BERT sentence embeddings embeddings = self . _extract_embeddings ( documents . Document ) # Reduce dimensionality with UMAP umap_embeddings = self . _reduce_dimensionality ( embeddings ) # Cluster UMAP embeddings with HDBSCAN documents , probabilities = self . _cluster_embeddings ( umap_embeddings , documents ) # Extract topics by calculating c-TF-IDF c_tf_idf = self . _extract_topics ( documents ) if self . nr_topics : documents = self . _reduce_topics ( documents , c_tf_idf ) probabilities = self . _map_probabilities ( probabilities ) predictions = documents . Topic . to_list () return predictions , probabilities Fit the models on a collection of documents, generate topics, and return the docs with topics Parameters Name Type Description Default documents List[str] A list of documents to fit on required Returns Type Description Tuple[List[int], numpy.ndarray] predictions: Topic predictions for each documents probabilities: The topic probability distribution get_topic ( self , topic ) \u00b6 Show source code in bertopic\\model.py 302 303 304 305 306 307 def get_topic ( self , topic : int ) -> Union [ Dict [ str , Tuple [ str , float ]], bool ]: \"\"\" Return top n words for a specific topic and their c-TF-IDF scores \"\"\" if self . topics . get ( topic ): return self . topics [ topic ] else : return False Return top n words for a specific topic and their c-TF-IDF scores get_topic_freq ( self , topic ) \u00b6 Show source code in bertopic\\model.py 313 314 315 def get_topic_freq ( self , topic : int ) -> int : \"\"\" Return the the size of a topic \"\"\" return self . topic_sizes . items ()[ topic ] Return the the size of a topic get_topics ( self ) \u00b6 Show source code in bertopic\\model.py 298 299 300 def get_topics ( self ) -> Dict [ str , Tuple [ str , float ]]: \"\"\" Return topics with top n words and their c-TF-IDF score \"\"\" return self . topics Return topics with top n words and their c-TF-IDF score get_topics_freq ( self ) \u00b6 Show source code in bertopic\\model.py 309 310 311 def get_topics_freq ( self ) -> pd . DataFrame : \"\"\" Return the the size of topics (descending order) \"\"\" return pd . DataFrame ( self . topic_sizes . items (), columns = [ 'Topic' , 'Count' ]) . sort_values ( \"Count\" , ascending = False ) Return the the size of topics (descending order) load ( path ) (classmethod) \u00b6 Show source code in bertopic\\model.py 446 447 448 449 450 @classmethod def load ( cls , path : str ): \"\"\" Loads the model from the specified path \"\"\" with open ( path , 'rb' ) as file : return joblib . load ( file ) Loads the model from the specified path save ( self , path ) \u00b6 Show source code in bertopic\\model.py 441 442 443 444 def save ( self , path : str ) -> None : \"\"\" Saves the model to the specified path \"\"\" with open ( path , 'wb' ) as file : joblib . dump ( self , file ) Saves the model to the specified path transform ( self , documents ) \u00b6 Show source code in bertopic\\model.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def transform ( self , documents : Union [ str , List [ str ]]) -> Tuple [ List [ int ], np . ndarray ]: \"\"\" After having fit a model, use transform to predict new instances Arguments: documents: A single document or a list of documents to fit on Returns: predictions: Topic predictions for each documents probabilities: The topic probability distribution \"\"\" if isinstance ( documents , str ): documents = [ documents ] embeddings = self . _extract_embeddings ( documents ) umap_embeddings = self . umap_model . transform ( embeddings ) probabilities = hdbscan . membership_vector ( self . cluster_model , umap_embeddings ) predictions , _ = hdbscan . approximate_predict ( self . cluster_model , umap_embeddings ) if self . mapped_topics : predictions = self . _map_predictions ( predictions ) probabilities = self . _map_probabilities ( probabilities ) if len ( documents ) == 1 : probabilities = probabilities . flatten () return predictions , probabilities After having fit a model, use transform to predict new instances Parameters Name Type Description Default documents Union[str, List[str]] A single document or a list of documents to fit on required Returns Type Description Tuple[List[int], numpy.ndarray] predictions: Topic predictions for each documents probabilities: The topic probability distribution visualize_distribution ( self , probabilities , min_probability = 0.01 , figsize = ( 10 , 5 ), save = False ) \u00b6 Show source code in bertopic\\model.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def visualize_distribution ( self , probabilities : np . ndarray , min_probability : float = 0.01 , figsize : tuple = ( 10 , 5 ), save : bool = False ) -> plt . Figure : \"\"\" Visualize the distribution of topic probabilities Arguments: probabilities: An array of probability scores min_probability: The minimum probability score to visualize. All others are ignored. figsize: The size of the figure save: Whether to save the resulting graph to probility.png Returns fig: The Matplotlib figure. \"\"\" # Get values and indices equal or exceed the minimum probability labels_idx = np . argwhere ( probabilities >= min_probability ) . flatten () vals = probabilities [ labels_idx ] . tolist () # Create labels labels = [] for idx in labels_idx : label = [] words = self . get_topic ( idx ) if words : for word in words [: 5 ]: label . append ( word [ 0 ]) label = str ( r \"$\\bf{Topic }$ \" + r \"$\\bf{\" + str ( idx ) + \":}$ \" + \" \" . join ( label )) labels . append ( label ) else : print ( idx , probabilities [ idx ]) vals . remove ( probabilities [ idx ]) pos = range ( len ( vals )) # Create figure fig , ax = plt . subplots ( figsize = figsize ) plt . hlines ( y = pos , xmin = 0 , xmax = vals , color = '#333F4B' , alpha = 0.2 , linewidth = 15 ) plt . hlines ( y = np . argmax ( vals ), xmin = 0 , xmax = max ( vals ), color = '#333F4B' , alpha = 1 , linewidth = 15 ) # Set ticks and labels ax . tick_params ( axis = 'both' , which = 'major' , labelsize = 12 ) ax . set_xlabel ( 'Probability' , fontsize = 15 , fontweight = 'black' , color = '#333F4B' ) ax . set_ylabel ( '' ) plt . yticks ( pos , labels ) fig . text ( 0 , 1 , 'Topic Probability Distribution' , fontsize = 15 , fontweight = 'black' , color = '#333F4B' ) # Update spine style ax . spines [ 'right' ] . set_visible ( False ) ax . spines [ 'top' ] . set_visible ( False ) ax . spines [ 'left' ] . set_bounds ( pos [ 0 ], pos [ - 1 ]) ax . spines [ 'bottom' ] . set_bounds ( 0 , max ( vals )) ax . spines [ 'bottom' ] . set_position (( 'axes' , - 0.02 )) ax . spines [ 'left' ] . set_position (( 'axes' , 0.02 )) fig . tight_layout () if save : fig . savefig ( \"probability.png\" , dpi = 300 , bbox_inches = 'tight' ) return fig Visualize the distribution of topic probabilities Parameters Name Type Description Default probabilities ndarray An array of probability scores required min_probability float The minimum probability score to visualize. All others are ignored. 0.01 figsize tuple The size of the figure (10, 5) save bool Whether to save the resulting graph to probility.png False Returns fig: The Matplotlib figure.","title":"BERTopic"},{"location":"api/bertopic.html#bertopic","text":"Transformer-based model for Topic Modeling Parameters Name Type Description Default bert_model str Model to use. Overview of options can be found here https://www.sbert.net/docs/pretrained_models.html 'distilbert-base-nli-mean-tokens' top_n_words int The number of words per topic to extract 20 nr_topics int Specifying the number of topics will reduce the initial number of topics to the value specified. This reduction can take a while as each reduction in topics (-1) activates a c-TF-IDF calculation. IF this is set to None, no reduction is applied. None n_gram_range Tuple[int, int] The n-gram range for the CountVectorizer. Advised to keep high values between 1 and 3. More would likely lead to memory issues. (1, 1) min_topic_size int The minimum size of the topic. 30 n_neighbors int The size of local neighborhood (in terms of number of neighboring sample points) used for manifold approximation (UMAP). 15 n_components int The dimension of the space to embed into when reducing dimensionality with UMAP. 5 stop_words Union[str, List[str]] Stopwords that can be used as either a list of strings, or the name of the language as a string. For example: 'english' or ['the', 'and', 'I']. None verbose bool Changes the verbosity of the model, Set to True if you want to track the stages of the model. False Usage: from bertopic import BERTopic from sklearn.datasets import fetch_20newsgroups docs = fetch_20newsgroups ( subset = 'all' )[ 'data' ] model = BERTopic ( \"distilbert-base-nli-mean-tokens\" , verbose = True ) topics = model . fit_transform ( docs )","title":"BERTopic"},{"location":"api/bertopic.html#bertopic.model.BERTopic.fit","text":"Show source code in bertopic\\model.py 90 91 92 93 94 95 96 97 98 def fit ( self , documents : List [ str ]): \"\"\" Fit the models (Bert, UMAP, and, HDBSCAN) on a collection of documents and generate topics Arguments: documents: A list of documents to fit on \"\"\" check_documents_type ( documents ) self . fit_transform ( documents ) return self Fit the models (Bert, UMAP, and, HDBSCAN) on a collection of documents and generate topics Parameters Name Type Description Default documents List[str] A list of documents to fit on required","title":"fit()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.fit_transform","text":"Show source code in bertopic\\model.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def fit_transform ( self , documents : List [ str ]) -> Tuple [ List [ int ], np . ndarray ]: \"\"\" Fit the models on a collection of documents, generate topics, and return the docs with topics Arguments: documents: A list of documents to fit on Returns: predictions: Topic predictions for each documents probabilities: The topic probability distribution \"\"\" check_documents_type ( documents ) documents = pd . DataFrame ({ \"Document\" : documents , \"ID\" : range ( len ( documents )), \"Topic\" : None }) # Extract BERT sentence embeddings embeddings = self . _extract_embeddings ( documents . Document ) # Reduce dimensionality with UMAP umap_embeddings = self . _reduce_dimensionality ( embeddings ) # Cluster UMAP embeddings with HDBSCAN documents , probabilities = self . _cluster_embeddings ( umap_embeddings , documents ) # Extract topics by calculating c-TF-IDF c_tf_idf = self . _extract_topics ( documents ) if self . nr_topics : documents = self . _reduce_topics ( documents , c_tf_idf ) probabilities = self . _map_probabilities ( probabilities ) predictions = documents . Topic . to_list () return predictions , probabilities Fit the models on a collection of documents, generate topics, and return the docs with topics Parameters Name Type Description Default documents List[str] A list of documents to fit on required Returns Type Description Tuple[List[int], numpy.ndarray] predictions: Topic predictions for each documents probabilities: The topic probability distribution","title":"fit_transform()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.get_topic","text":"Show source code in bertopic\\model.py 302 303 304 305 306 307 def get_topic ( self , topic : int ) -> Union [ Dict [ str , Tuple [ str , float ]], bool ]: \"\"\" Return top n words for a specific topic and their c-TF-IDF scores \"\"\" if self . topics . get ( topic ): return self . topics [ topic ] else : return False Return top n words for a specific topic and their c-TF-IDF scores","title":"get_topic()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.get_topic_freq","text":"Show source code in bertopic\\model.py 313 314 315 def get_topic_freq ( self , topic : int ) -> int : \"\"\" Return the the size of a topic \"\"\" return self . topic_sizes . items ()[ topic ] Return the the size of a topic","title":"get_topic_freq()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.get_topics","text":"Show source code in bertopic\\model.py 298 299 300 def get_topics ( self ) -> Dict [ str , Tuple [ str , float ]]: \"\"\" Return topics with top n words and their c-TF-IDF score \"\"\" return self . topics Return topics with top n words and their c-TF-IDF score","title":"get_topics()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.get_topics_freq","text":"Show source code in bertopic\\model.py 309 310 311 def get_topics_freq ( self ) -> pd . DataFrame : \"\"\" Return the the size of topics (descending order) \"\"\" return pd . DataFrame ( self . topic_sizes . items (), columns = [ 'Topic' , 'Count' ]) . sort_values ( \"Count\" , ascending = False ) Return the the size of topics (descending order)","title":"get_topics_freq()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.load","text":"Show source code in bertopic\\model.py 446 447 448 449 450 @classmethod def load ( cls , path : str ): \"\"\" Loads the model from the specified path \"\"\" with open ( path , 'rb' ) as file : return joblib . load ( file ) Loads the model from the specified path","title":"load()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.save","text":"Show source code in bertopic\\model.py 441 442 443 444 def save ( self , path : str ) -> None : \"\"\" Saves the model to the specified path \"\"\" with open ( path , 'wb' ) as file : joblib . dump ( self , file ) Saves the model to the specified path","title":"save()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.transform","text":"Show source code in bertopic\\model.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def transform ( self , documents : Union [ str , List [ str ]]) -> Tuple [ List [ int ], np . ndarray ]: \"\"\" After having fit a model, use transform to predict new instances Arguments: documents: A single document or a list of documents to fit on Returns: predictions: Topic predictions for each documents probabilities: The topic probability distribution \"\"\" if isinstance ( documents , str ): documents = [ documents ] embeddings = self . _extract_embeddings ( documents ) umap_embeddings = self . umap_model . transform ( embeddings ) probabilities = hdbscan . membership_vector ( self . cluster_model , umap_embeddings ) predictions , _ = hdbscan . approximate_predict ( self . cluster_model , umap_embeddings ) if self . mapped_topics : predictions = self . _map_predictions ( predictions ) probabilities = self . _map_probabilities ( probabilities ) if len ( documents ) == 1 : probabilities = probabilities . flatten () return predictions , probabilities After having fit a model, use transform to predict new instances Parameters Name Type Description Default documents Union[str, List[str]] A single document or a list of documents to fit on required Returns Type Description Tuple[List[int], numpy.ndarray] predictions: Topic predictions for each documents probabilities: The topic probability distribution","title":"transform()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.visualize_distribution","text":"Show source code in bertopic\\model.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def visualize_distribution ( self , probabilities : np . ndarray , min_probability : float = 0.01 , figsize : tuple = ( 10 , 5 ), save : bool = False ) -> plt . Figure : \"\"\" Visualize the distribution of topic probabilities Arguments: probabilities: An array of probability scores min_probability: The minimum probability score to visualize. All others are ignored. figsize: The size of the figure save: Whether to save the resulting graph to probility.png Returns fig: The Matplotlib figure. \"\"\" # Get values and indices equal or exceed the minimum probability labels_idx = np . argwhere ( probabilities >= min_probability ) . flatten () vals = probabilities [ labels_idx ] . tolist () # Create labels labels = [] for idx in labels_idx : label = [] words = self . get_topic ( idx ) if words : for word in words [: 5 ]: label . append ( word [ 0 ]) label = str ( r \"$\\bf{Topic }$ \" + r \"$\\bf{\" + str ( idx ) + \":}$ \" + \" \" . join ( label )) labels . append ( label ) else : print ( idx , probabilities [ idx ]) vals . remove ( probabilities [ idx ]) pos = range ( len ( vals )) # Create figure fig , ax = plt . subplots ( figsize = figsize ) plt . hlines ( y = pos , xmin = 0 , xmax = vals , color = '#333F4B' , alpha = 0.2 , linewidth = 15 ) plt . hlines ( y = np . argmax ( vals ), xmin = 0 , xmax = max ( vals ), color = '#333F4B' , alpha = 1 , linewidth = 15 ) # Set ticks and labels ax . tick_params ( axis = 'both' , which = 'major' , labelsize = 12 ) ax . set_xlabel ( 'Probability' , fontsize = 15 , fontweight = 'black' , color = '#333F4B' ) ax . set_ylabel ( '' ) plt . yticks ( pos , labels ) fig . text ( 0 , 1 , 'Topic Probability Distribution' , fontsize = 15 , fontweight = 'black' , color = '#333F4B' ) # Update spine style ax . spines [ 'right' ] . set_visible ( False ) ax . spines [ 'top' ] . set_visible ( False ) ax . spines [ 'left' ] . set_bounds ( pos [ 0 ], pos [ - 1 ]) ax . spines [ 'bottom' ] . set_bounds ( 0 , max ( vals )) ax . spines [ 'bottom' ] . set_position (( 'axes' , - 0.02 )) ax . spines [ 'left' ] . set_position (( 'axes' , 0.02 )) fig . tight_layout () if save : fig . savefig ( \"probability.png\" , dpi = 300 , bbox_inches = 'tight' ) return fig Visualize the distribution of topic probabilities Parameters Name Type Description Default probabilities ndarray An array of probability scores required min_probability float The minimum probability score to visualize. All others are ignored. 0.01 figsize tuple The size of the figure (10, 5) save bool Whether to save the resulting graph to probility.png False Returns fig: The Matplotlib figure.","title":"visualize_distribution()"},{"location":"api/ctfidf.html","text":"c-TF-IDF \u00b6 A Class-based TF-IDF procedure using scikit-learns TfidfTransformer as a base. C-TF-IDF can best be explained as a TF-IDF formula adopted for multiple classes by joining all documents per class. Thus, each class is converted to a single document instead of set of documents. Then, the frequency of words t are extracted for each class i and divided by the total number of words w . Next, the total, unjoined, number of documents across all classes m is divided by the total sum of word i across all classes. fit ( self , X , n_samples ) \u00b6 Show source code in bertopic\\ctfidf.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def fit ( self , X : sp . csr_matrix , n_samples : int ): \"\"\"Learn the idf vector (global term weights). Arguments: X: A matrix of term/token counts. n_samples: Number of total documents \"\"\" X = check_array ( X , accept_sparse = ( 'csr' , 'csc' )) if not sp . issparse ( X ): X = sp . csr_matrix ( X ) dtype = np . float64 if self . use_idf : _ , n_features = X . shape self . df = np . squeeze ( np . asarray ( X . sum ( axis = 0 ))) idf = np . log ( n_samples / self . df ) self . _idf_diag = sp . diags ( idf , offsets = 0 , shape = ( n_features , n_features ), format = 'csr' , dtype = dtype ) return self Learn the idf vector (global term weights). Parameters Name Type Description Default X csr_matrix A matrix of term/token counts. required n_samples int Number of total documents required transform ( self , X , copy = True ) \u00b6 Show source code in bertopic\\ctfidf.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def transform ( self , X : sp . csr_matrix , copy = True ): \"\"\"Transform a count-based matrix to c-TF-IDF Arguments: X (sparse matrix): A matrix of term/token counts. Returns: X (sparse matrix): A c-TF-IDF matrix \"\"\" if self . use_idf : X = normalize ( X , axis = 1 , norm = 'l1' , copy = False ) X = X * self . _idf_diag return X Transform a count-based matrix to c-TF-IDF Parameters Name Type Description Default X csr_matrix A matrix of term/token counts. required Returns Type Description `` X (sparse matrix): A c-TF-IDF matrix","title":"cTFIDF"},{"location":"api/ctfidf.html#c-tf-idf","text":"A Class-based TF-IDF procedure using scikit-learns TfidfTransformer as a base. C-TF-IDF can best be explained as a TF-IDF formula adopted for multiple classes by joining all documents per class. Thus, each class is converted to a single document instead of set of documents. Then, the frequency of words t are extracted for each class i and divided by the total number of words w . Next, the total, unjoined, number of documents across all classes m is divided by the total sum of word i across all classes.","title":"c-TF-IDF"},{"location":"api/ctfidf.html#bertopic.ctfidf.ClassTFIDF.fit","text":"Show source code in bertopic\\ctfidf.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def fit ( self , X : sp . csr_matrix , n_samples : int ): \"\"\"Learn the idf vector (global term weights). Arguments: X: A matrix of term/token counts. n_samples: Number of total documents \"\"\" X = check_array ( X , accept_sparse = ( 'csr' , 'csc' )) if not sp . issparse ( X ): X = sp . csr_matrix ( X ) dtype = np . float64 if self . use_idf : _ , n_features = X . shape self . df = np . squeeze ( np . asarray ( X . sum ( axis = 0 ))) idf = np . log ( n_samples / self . df ) self . _idf_diag = sp . diags ( idf , offsets = 0 , shape = ( n_features , n_features ), format = 'csr' , dtype = dtype ) return self Learn the idf vector (global term weights). Parameters Name Type Description Default X csr_matrix A matrix of term/token counts. required n_samples int Number of total documents required","title":"fit()"},{"location":"api/ctfidf.html#bertopic.ctfidf.ClassTFIDF.transform","text":"Show source code in bertopic\\ctfidf.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def transform ( self , X : sp . csr_matrix , copy = True ): \"\"\"Transform a count-based matrix to c-TF-IDF Arguments: X (sparse matrix): A matrix of term/token counts. Returns: X (sparse matrix): A c-TF-IDF matrix \"\"\" if self . use_idf : X = normalize ( X , axis = 1 , norm = 'l1' , copy = False ) X = X * self . _idf_diag return X Transform a count-based matrix to c-TF-IDF Parameters Name Type Description Default X csr_matrix A matrix of term/token counts. required Returns Type Description `` X (sparse matrix): A c-TF-IDF matrix","title":"transform()"}]}