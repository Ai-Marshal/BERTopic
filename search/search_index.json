{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"BERTopic \u00b6 BERTopic is a topic modeling technique that leverages BERT embeddings and c-TF-IDF to create dense clusters allowing for easily interpretable topics whilst keeping important words in the topic descriptions. Corresponding medium post can be found here . About the Project \u00b6 The initial purpose of this project was to generalize Top2Vec such that it could be used with state-of-art pre-trained transformer models. However, this proved difficult due to the different natures of Doc2Vec and transformer models. Instead, I decided to come up with a different algorithm that could use BERT and \ud83e\udd17 transformers embeddings. The results is BERTopic , an algorithm for generating topics using state-of-the-art embeddings. Installation \u00b6 PyTorch 1.2.0 or higher is recommended. If the install below gives an error, please install pytorch first here . Installation can be done using pypi : pip install bertopic Usage \u00b6 Below is an example of how to use the model. The example uses the 20 newsgroups dataset. from bertopic import BERTopic from sklearn.datasets import fetch_20newsgroups docs = fetch_20newsgroups ( subset = 'all' )[ 'data' ] model = BERTopic ( \"distilbert-base-nli-mean-tokens\" , verbose = True ) topics = model . fit_transform ( docs ) The resulting topics can be accessed through model.get_topic(topic) : >>> model . get_topic ( 9 ) [( 'game' , 0.005251396890032802 ), ( 'team' , 0.00482651185323754 ), ( 'hockey' , 0.004335032060690186 ), ( 'players' , 0.0034782716706978963 ), ( 'games' , 0.0032873248432630227 ), ( 'season' , 0.003218987432255393 ), ( 'play' , 0.0031855141725669637 ), ( 'year' , 0.002962343114817677 ), ( 'nhl' , 0.0029577648449943144 ), ( 'baseball' , 0.0029245163154193524 )] You can find an overview of all models currently in BERTopic here and here . Overview \u00b6 Methods Code Returns Access single topic model.get_topic(12) Tuple[Word, Score] Access all topics model.get_topic() List[Tuple[Word, Score]] Get single topic freq model.get_topic_freq(12) int Get all topic freq model.get_topics_freq() DataFrame Fit the model model.fit(docs]) - Predict new documents model.transform([new_doc]) List[int] Save model model.save(\"my_model\") - Load model BERTopic.load(\"my_model\") - NOTE : The embeddings itself are not preserved in the model as they are only vital for creating the clusters. Therefore, it is advised to only use fit and then transform if you are looking to generalize the model to new documents. For existing documents, it is best to use fit_transform directly as it only needs to generate the document embeddings once. Google Colaboratory \u00b6 Since we are using transformer-based embeddings you might want to leverage gpu-acceleration to speed up the model. For that, I have created a tutorial Google Colab Notebook that you can use to run the model as shown above. If you want to tweak the inner workings or follow along with the medium post, use this notebook instead. References \u00b6 Angelov, D. (2020). Top2Vec: Distributed Representations of Topics. arXiv preprint arXiv :2008.09470.","title":"Index"},{"location":"index.html#bertopic","text":"BERTopic is a topic modeling technique that leverages BERT embeddings and c-TF-IDF to create dense clusters allowing for easily interpretable topics whilst keeping important words in the topic descriptions. Corresponding medium post can be found here .","title":"BERTopic"},{"location":"index.html#about-the-project","text":"The initial purpose of this project was to generalize Top2Vec such that it could be used with state-of-art pre-trained transformer models. However, this proved difficult due to the different natures of Doc2Vec and transformer models. Instead, I decided to come up with a different algorithm that could use BERT and \ud83e\udd17 transformers embeddings. The results is BERTopic , an algorithm for generating topics using state-of-the-art embeddings.","title":"About the Project"},{"location":"index.html#installation","text":"PyTorch 1.2.0 or higher is recommended. If the install below gives an error, please install pytorch first here . Installation can be done using pypi : pip install bertopic","title":"Installation"},{"location":"index.html#usage","text":"Below is an example of how to use the model. The example uses the 20 newsgroups dataset. from bertopic import BERTopic from sklearn.datasets import fetch_20newsgroups docs = fetch_20newsgroups ( subset = 'all' )[ 'data' ] model = BERTopic ( \"distilbert-base-nli-mean-tokens\" , verbose = True ) topics = model . fit_transform ( docs ) The resulting topics can be accessed through model.get_topic(topic) : >>> model . get_topic ( 9 ) [( 'game' , 0.005251396890032802 ), ( 'team' , 0.00482651185323754 ), ( 'hockey' , 0.004335032060690186 ), ( 'players' , 0.0034782716706978963 ), ( 'games' , 0.0032873248432630227 ), ( 'season' , 0.003218987432255393 ), ( 'play' , 0.0031855141725669637 ), ( 'year' , 0.002962343114817677 ), ( 'nhl' , 0.0029577648449943144 ), ( 'baseball' , 0.0029245163154193524 )] You can find an overview of all models currently in BERTopic here and here .","title":"Usage"},{"location":"index.html#overview","text":"Methods Code Returns Access single topic model.get_topic(12) Tuple[Word, Score] Access all topics model.get_topic() List[Tuple[Word, Score]] Get single topic freq model.get_topic_freq(12) int Get all topic freq model.get_topics_freq() DataFrame Fit the model model.fit(docs]) - Predict new documents model.transform([new_doc]) List[int] Save model model.save(\"my_model\") - Load model BERTopic.load(\"my_model\") - NOTE : The embeddings itself are not preserved in the model as they are only vital for creating the clusters. Therefore, it is advised to only use fit and then transform if you are looking to generalize the model to new documents. For existing documents, it is best to use fit_transform directly as it only needs to generate the document embeddings once.","title":"Overview"},{"location":"index.html#google-colaboratory","text":"Since we are using transformer-based embeddings you might want to leverage gpu-acceleration to speed up the model. For that, I have created a tutorial Google Colab Notebook that you can use to run the model as shown above. If you want to tweak the inner workings or follow along with the medium post, use this notebook instead.","title":"Google Colaboratory"},{"location":"index.html#references","text":"Angelov, D. (2020). Top2Vec: Distributed Representations of Topics. arXiv preprint arXiv :2008.09470.","title":"References"},{"location":"algorithm.html","text":"The Algorithm \u00b6 The algorithm contains, roughly, 3 stages: Extract document embeddings with Sentence Transformers Cluster document embeddings to create groups of similar documents with UMAP and HDBSCAN Extract and reduce topics with c-TF-IDF Sentence Transformer \u00b6 We start by creating document embeddings from a set of documents using sentence-transformer . These models are pre-trained for many language and are great for creating either document- or sentence-embeddings. If you have long documents, I would advise you to split up your documents into paragraphs or sentences as a BERT-based model in sentence-transformer typically has a token limit. UMAP + HDBSCAN \u00b6 Next, in order to cluster the documents using a clustering algorithm such as HDBSCAN we first need to reduce its dimensionality as HDBCAN is prone to the curse of dimensionality. Thus, we first lower dimensionality with UMAP as it preserves local structure well after which we can use HDBSCAN to cluster similar documents. c-TF-IDF \u00b6 What we want to know from the clusters that we generated, is what makes one cluster, based on their content, different from another? To solve this, we can modify TF-IDF such that it allows for interesting words per topic instead of per document. When you apply TF-IDF as usual on a set of documents, what you are basically doing is comparing the importance of words between documents. Now, what if, we instead treat all documents in a single category (e.g., a cluster) as a single document and then apply TF-IDF? The result would be importance scores for words within a cluster. The more important words are within a cluster, the more it is representative of that topic. In other words, if we extract the most important words per cluster, we get descriptions of topics ! Each cluster is converted to a single document instead of a set of documents. Then, the frequency of word t are extracted for each class i and divided by the total number of words w . This action can now be seen as a form of regularization of frequent words in the class. Next, the total, unjoined, number of documents m is divided by the total frequency of word t across all classes n .","title":"Algorithm"},{"location":"algorithm.html#the-algorithm","text":"The algorithm contains, roughly, 3 stages: Extract document embeddings with Sentence Transformers Cluster document embeddings to create groups of similar documents with UMAP and HDBSCAN Extract and reduce topics with c-TF-IDF","title":"The Algorithm"},{"location":"algorithm.html#sentence-transformer","text":"We start by creating document embeddings from a set of documents using sentence-transformer . These models are pre-trained for many language and are great for creating either document- or sentence-embeddings. If you have long documents, I would advise you to split up your documents into paragraphs or sentences as a BERT-based model in sentence-transformer typically has a token limit.","title":"Sentence Transformer"},{"location":"algorithm.html#umap-hdbscan","text":"Next, in order to cluster the documents using a clustering algorithm such as HDBSCAN we first need to reduce its dimensionality as HDBCAN is prone to the curse of dimensionality. Thus, we first lower dimensionality with UMAP as it preserves local structure well after which we can use HDBSCAN to cluster similar documents.","title":"UMAP + HDBSCAN"},{"location":"algorithm.html#c-tf-idf","text":"What we want to know from the clusters that we generated, is what makes one cluster, based on their content, different from another? To solve this, we can modify TF-IDF such that it allows for interesting words per topic instead of per document. When you apply TF-IDF as usual on a set of documents, what you are basically doing is comparing the importance of words between documents. Now, what if, we instead treat all documents in a single category (e.g., a cluster) as a single document and then apply TF-IDF? The result would be importance scores for words within a cluster. The more important words are within a cluster, the more it is representative of that topic. In other words, if we extract the most important words per cluster, we get descriptions of topics ! Each cluster is converted to a single document instead of a set of documents. Then, the frequency of word t are extracted for each class i and divided by the total number of words w . This action can now be seen as a form of regularization of frequent words in the class. Next, the total, unjoined, number of documents m is divided by the total frequency of word t across all classes n .","title":"c-TF-IDF"},{"location":"api/bertopic.html","text":"BERTopic \u00b6 \u00b6 Transformer-based model for Topic Modeling Parameters: Name Type Description Default bert_model Model to use. Overview of options can be found here https://www.sbert.net/docs/pretrained_models.html required top_n_words The number of words per topic to extract required nr_topics Specifying the number of topics will reduce the initial number of topics to the value specified. This reduction can take a while as each reduction in topics (-1) activates a c-TF-IDF calculation. IF this is set to None, no reduction is applied. required n_gram_range The n-gram range for the CountVectorizer. Advised to keep high values between 1 and 3. More would likely lead to memory issues. required min_topic_size The minimum size of the topic. required n_neighbors The size of local neighborhood (in terms of number of neighboring sample points) used for manifold approximation (UMAP). required n_components The dimension of the space to embed into when reducing dimensionality with UMAP. required stop_words Stopwords that can be used as either a list of strings, or the name of the language as a string. For example: 'english' or ['the', 'and', 'I']. required verbose Changes the verbosity of the model, Set to True if you want to track the stages of the model. required Usage: from bertopic import BERTopic from sklearn.datasets import fetch_20newsgroups docs = fetch_20newsgroups ( subset = 'all' )[ 'data' ] model = BERTopic ( \"distilbert-base-nli-mean-tokens\" , verbose = True ) topics = model . fit_transform ( docs ) fit ( self , documents ) \u00b6 Fit the models (Bert, UMAP, and, HDBSCAN) on a collection of documents and generate topics Parameters: Name Type Description Default documents List[str] A list of documents to fit on required Source code in bertopic\\model.py def fit ( self , documents : List [ str ]): \"\"\" Fit the models (Bert, UMAP, and, HDBSCAN) on a collection of documents and generate topics Arguments: documents: A list of documents to fit on \"\"\" check_documents_type ( documents ) self . fit_transform ( documents ) return self fit_transform ( self , documents ) \u00b6 Fit the models on a collection of documents, generate topics, and return the docs with topics Parameters: Name Type Description Default documents List[str] A list of documents to fit on required Returns: Type Description List[int] predictions: Topic predictions for each documents Source code in bertopic\\model.py def fit_transform ( self , documents : List [ str ]) -> List [ int ]: \"\"\" Fit the models on a collection of documents, generate topics, and return the docs with topics Arguments: documents: A list of documents to fit on Returns: predictions: Topic predictions for each documents \"\"\" check_documents_type ( documents ) documents = pd . DataFrame ({ \"Document\" : documents , \"ID\" : range ( len ( documents )), \"Topic\" : None }) # Extract BERT sentence embeddings embeddings = self . _extract_embeddings ( documents . Document ) # Reduce dimensionality with UMAP umap_embeddings = self . _reduce_dimensionality ( embeddings ) # Cluster UMAP embeddings with HDBSCAN documents = self . _cluster_embeddings ( umap_embeddings , documents ) # Extract topics by calculating c-TF-IDF c_tf_idf = self . _extract_topics ( documents ) if self . nr_topics : documents = self . _reduce_topics ( documents , c_tf_idf ) predictions = documents . Topic . to_list () return predictions get_topic ( self , topic ) \u00b6 Return top n words for a specific topic and their c-TF-IDF scores Source code in bertopic\\model.py def get_topic ( self , topic : int ) -> Dict [ str , Tuple [ str , float ]]: \"\"\" Return top n words for a specific topic and their c-TF-IDF scores \"\"\" return self . topics [ topic ] get_topic_freq ( self , topic ) \u00b6 Return the the size of a topic Source code in bertopic\\model.py def get_topic_freq ( self , topic : int ) -> int : \"\"\" Return the the size of a topic \"\"\" return self . topic_sizes . items ()[ topic ] get_topics ( self ) \u00b6 Return topics with top n words and their c-TF-IDF score Source code in bertopic\\model.py def get_topics ( self ) -> Dict [ str , Tuple [ str , float ]]: \"\"\" Return topics with top n words and their c-TF-IDF score \"\"\" return self . topics get_topics_freq ( self ) \u00b6 Return the the size of topics (descending order) Source code in bertopic\\model.py def get_topics_freq ( self ) -> pd . DataFrame : \"\"\" Return the the size of topics (descending order) \"\"\" return pd . DataFrame ( self . topic_sizes . items (), columns = [ 'Topic' , 'Count' ]) . sort_values ( \"Count\" , ascending = False ) load ( path ) classmethod \u00b6 Loads the model from the specified path Source code in bertopic\\model.py @classmethod def load ( cls , path : str ): \"\"\" Loads the model from the specified path \"\"\" with open ( path , 'rb' ) as file : return joblib . load ( file ) save ( self , path ) \u00b6 Saves the model to the specified path Source code in bertopic\\model.py def save ( self , path : str ) -> None : \"\"\" Saves the model to the specified path \"\"\" with open ( path , 'wb' ) as file : joblib . dump ( self , file ) transform ( self , documents ) \u00b6 After having fit a model, use transform to predict new instances Source code in bertopic\\model.py def transform ( self , documents : Union [ str , List [ str ]]) -> List [ int ]: \"\"\" After having fit a model, use transform to predict new instances \"\"\" if isinstance ( documents , str ): documents = [ documents ] embeddings = self . _extract_embeddings ( documents ) umap_embeddings = self . umap_model . transform ( embeddings ) predictions , strengths = hdbscan . approximate_predict ( self . cluster_model , umap_embeddings ) if self . mapped_topics : predictions = self . _map_predictions ( predictions ) return predictions","title":"BERTopic"},{"location":"api/bertopic.html#bertopic","text":"","title":"BERTopic"},{"location":"api/bertopic.html#bertopic.model.BERTopic","text":"Transformer-based model for Topic Modeling Parameters: Name Type Description Default bert_model Model to use. Overview of options can be found here https://www.sbert.net/docs/pretrained_models.html required top_n_words The number of words per topic to extract required nr_topics Specifying the number of topics will reduce the initial number of topics to the value specified. This reduction can take a while as each reduction in topics (-1) activates a c-TF-IDF calculation. IF this is set to None, no reduction is applied. required n_gram_range The n-gram range for the CountVectorizer. Advised to keep high values between 1 and 3. More would likely lead to memory issues. required min_topic_size The minimum size of the topic. required n_neighbors The size of local neighborhood (in terms of number of neighboring sample points) used for manifold approximation (UMAP). required n_components The dimension of the space to embed into when reducing dimensionality with UMAP. required stop_words Stopwords that can be used as either a list of strings, or the name of the language as a string. For example: 'english' or ['the', 'and', 'I']. required verbose Changes the verbosity of the model, Set to True if you want to track the stages of the model. required Usage: from bertopic import BERTopic from sklearn.datasets import fetch_20newsgroups docs = fetch_20newsgroups ( subset = 'all' )[ 'data' ] model = BERTopic ( \"distilbert-base-nli-mean-tokens\" , verbose = True ) topics = model . fit_transform ( docs )","title":"bertopic.model.BERTopic"},{"location":"api/bertopic.html#bertopic.model.BERTopic.fit","text":"Fit the models (Bert, UMAP, and, HDBSCAN) on a collection of documents and generate topics Parameters: Name Type Description Default documents List[str] A list of documents to fit on required Source code in bertopic\\model.py def fit ( self , documents : List [ str ]): \"\"\" Fit the models (Bert, UMAP, and, HDBSCAN) on a collection of documents and generate topics Arguments: documents: A list of documents to fit on \"\"\" check_documents_type ( documents ) self . fit_transform ( documents ) return self","title":"fit()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.fit_transform","text":"Fit the models on a collection of documents, generate topics, and return the docs with topics Parameters: Name Type Description Default documents List[str] A list of documents to fit on required Returns: Type Description List[int] predictions: Topic predictions for each documents Source code in bertopic\\model.py def fit_transform ( self , documents : List [ str ]) -> List [ int ]: \"\"\" Fit the models on a collection of documents, generate topics, and return the docs with topics Arguments: documents: A list of documents to fit on Returns: predictions: Topic predictions for each documents \"\"\" check_documents_type ( documents ) documents = pd . DataFrame ({ \"Document\" : documents , \"ID\" : range ( len ( documents )), \"Topic\" : None }) # Extract BERT sentence embeddings embeddings = self . _extract_embeddings ( documents . Document ) # Reduce dimensionality with UMAP umap_embeddings = self . _reduce_dimensionality ( embeddings ) # Cluster UMAP embeddings with HDBSCAN documents = self . _cluster_embeddings ( umap_embeddings , documents ) # Extract topics by calculating c-TF-IDF c_tf_idf = self . _extract_topics ( documents ) if self . nr_topics : documents = self . _reduce_topics ( documents , c_tf_idf ) predictions = documents . Topic . to_list () return predictions","title":"fit_transform()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.get_topic","text":"Return top n words for a specific topic and their c-TF-IDF scores Source code in bertopic\\model.py def get_topic ( self , topic : int ) -> Dict [ str , Tuple [ str , float ]]: \"\"\" Return top n words for a specific topic and their c-TF-IDF scores \"\"\" return self . topics [ topic ]","title":"get_topic()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.get_topic_freq","text":"Return the the size of a topic Source code in bertopic\\model.py def get_topic_freq ( self , topic : int ) -> int : \"\"\" Return the the size of a topic \"\"\" return self . topic_sizes . items ()[ topic ]","title":"get_topic_freq()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.get_topics","text":"Return topics with top n words and their c-TF-IDF score Source code in bertopic\\model.py def get_topics ( self ) -> Dict [ str , Tuple [ str , float ]]: \"\"\" Return topics with top n words and their c-TF-IDF score \"\"\" return self . topics","title":"get_topics()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.get_topics_freq","text":"Return the the size of topics (descending order) Source code in bertopic\\model.py def get_topics_freq ( self ) -> pd . DataFrame : \"\"\" Return the the size of topics (descending order) \"\"\" return pd . DataFrame ( self . topic_sizes . items (), columns = [ 'Topic' , 'Count' ]) . sort_values ( \"Count\" , ascending = False )","title":"get_topics_freq()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.load","text":"Loads the model from the specified path Source code in bertopic\\model.py @classmethod def load ( cls , path : str ): \"\"\" Loads the model from the specified path \"\"\" with open ( path , 'rb' ) as file : return joblib . load ( file )","title":"load()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.save","text":"Saves the model to the specified path Source code in bertopic\\model.py def save ( self , path : str ) -> None : \"\"\" Saves the model to the specified path \"\"\" with open ( path , 'wb' ) as file : joblib . dump ( self , file )","title":"save()"},{"location":"api/bertopic.html#bertopic.model.BERTopic.transform","text":"After having fit a model, use transform to predict new instances Source code in bertopic\\model.py def transform ( self , documents : Union [ str , List [ str ]]) -> List [ int ]: \"\"\" After having fit a model, use transform to predict new instances \"\"\" if isinstance ( documents , str ): documents = [ documents ] embeddings = self . _extract_embeddings ( documents ) umap_embeddings = self . umap_model . transform ( embeddings ) predictions , strengths = hdbscan . approximate_predict ( self . cluster_model , umap_embeddings ) if self . mapped_topics : predictions = self . _map_predictions ( predictions ) return predictions","title":"transform()"},{"location":"api/ctfidf.html","text":"c-TF-IDF \u00b6 \u00b6 A Class-based TF-IDF procedure using scikit-learns TfidfTransformer as a base. C-TF-IDF can best be explained as a TF-IDF formula adopted for multiple classes by joining all documents per class. Thus, each class is converted to a single document instead of set of documents. Then, the frequency of words t are extracted for each class i and divided by the total number of words w . Next, the total, unjoined, number of documents across all classes m is divided by the total sum of word i across all classes. fit ( self , X , n_samples ) \u00b6 Learn the idf vector (global term weights). Parameters: Name Type Description Default X csr_matrix A matrix of term/token counts. required n_samples int Number of total documents required Source code in bertopic\\ctfidf.py def fit ( self , X : sp . csr_matrix , n_samples : int ): \"\"\"Learn the idf vector (global term weights). Arguments: X: A matrix of term/token counts. n_samples: Number of total documents \"\"\" X = check_array ( X , accept_sparse = ( 'csr' , 'csc' )) if not sp . issparse ( X ): X = sp . csr_matrix ( X ) dtype = np . float64 if self . use_idf : _ , n_features = X . shape self . df = np . squeeze ( np . asarray ( X . sum ( axis = 0 ))) idf = np . log ( n_samples / self . df ) self . _idf_diag = sp . diags ( idf , offsets = 0 , shape = ( n_features , n_features ), format = 'csr' , dtype = dtype ) return self transform ( self , X , copy = True ) \u00b6 Transform a count-based matrix to c-TF-IDF Parameters: Name Type Description Default X csr_matrix A matrix of term/token counts. required Returns: Type Description X (sparse matrix) A c-TF-IDF matrix Source code in bertopic\\ctfidf.py def transform ( self , X : sp . csr_matrix , copy = True ): \"\"\"Transform a count-based matrix to c-TF-IDF Arguments: X (sparse matrix): A matrix of term/token counts. Returns: X (sparse matrix): A c-TF-IDF matrix \"\"\" if self . use_idf : X = normalize ( X , axis = 1 , norm = 'l1' , copy = False ) X = X * self . _idf_diag return X","title":"cTFIDF"},{"location":"api/ctfidf.html#c-tf-idf","text":"","title":"c-TF-IDF"},{"location":"api/ctfidf.html#bertopic.ctfidf.ClassTFIDF","text":"A Class-based TF-IDF procedure using scikit-learns TfidfTransformer as a base. C-TF-IDF can best be explained as a TF-IDF formula adopted for multiple classes by joining all documents per class. Thus, each class is converted to a single document instead of set of documents. Then, the frequency of words t are extracted for each class i and divided by the total number of words w . Next, the total, unjoined, number of documents across all classes m is divided by the total sum of word i across all classes.","title":"bertopic.ctfidf.ClassTFIDF"},{"location":"api/ctfidf.html#bertopic.ctfidf.ClassTFIDF.fit","text":"Learn the idf vector (global term weights). Parameters: Name Type Description Default X csr_matrix A matrix of term/token counts. required n_samples int Number of total documents required Source code in bertopic\\ctfidf.py def fit ( self , X : sp . csr_matrix , n_samples : int ): \"\"\"Learn the idf vector (global term weights). Arguments: X: A matrix of term/token counts. n_samples: Number of total documents \"\"\" X = check_array ( X , accept_sparse = ( 'csr' , 'csc' )) if not sp . issparse ( X ): X = sp . csr_matrix ( X ) dtype = np . float64 if self . use_idf : _ , n_features = X . shape self . df = np . squeeze ( np . asarray ( X . sum ( axis = 0 ))) idf = np . log ( n_samples / self . df ) self . _idf_diag = sp . diags ( idf , offsets = 0 , shape = ( n_features , n_features ), format = 'csr' , dtype = dtype ) return self","title":"fit()"},{"location":"api/ctfidf.html#bertopic.ctfidf.ClassTFIDF.transform","text":"Transform a count-based matrix to c-TF-IDF Parameters: Name Type Description Default X csr_matrix A matrix of term/token counts. required Returns: Type Description X (sparse matrix) A c-TF-IDF matrix Source code in bertopic\\ctfidf.py def transform ( self , X : sp . csr_matrix , copy = True ): \"\"\"Transform a count-based matrix to c-TF-IDF Arguments: X (sparse matrix): A matrix of term/token counts. Returns: X (sparse matrix): A c-TF-IDF matrix \"\"\" if self . use_idf : X = normalize ( X , axis = 1 , norm = 'l1' , copy = False ) X = X * self . _idf_diag return X","title":"transform()"}]}